Description: The patch fixes performance schema test failures
on the platforms that do not have a cycle timer implementation.

Remove this once upstream has released an official fix.
Author: Alexander Barkov <bar@mariadb.org>
Bug: https://mariadb.atlassian.net/browse/MDEV-8692

--- /dev/null
+++ b/mysql-test/suite/perfschema/include/have_timer_cycle.inc
@@ -0,0 +1,4 @@
+if (!`SELECT count(*) FROM performance_schema.performance_timers WHERE timer_name='CYCLE' AND timer_frequency IS NOT NULL`)
+{
+  Skip Need performance timer CYCLE;
+}
--- a/mysql-test/suite/perfschema/r/privilege.result
+++ b/mysql-test/suite/perfschema/r/privilege.result
@@ -554,7 +554,7 @@ ERROR 42000: DROP command denied to user
 #
 # Grant access to change tables with the root account
 GRANT UPDATE ON performance_schema.setup_consumers TO pfs_user_4;
-GRANT UPDATE ON performance_schema.setup_timers TO pfs_user_4;
+GRANT UPDATE, SELECT ON performance_schema.setup_timers TO pfs_user_4;
 GRANT UPDATE, SELECT ON performance_schema.setup_instruments TO pfs_user_4;
 GRANT DROP ON performance_schema.events_waits_current TO pfs_user_4;
 GRANT DROP ON performance_schema.events_waits_history TO pfs_user_4;
@@ -565,7 +565,7 @@ UPDATE performance_schema.setup_instrume
 WHERE name LIKE 'wait/synch/mutex/%'
    OR name LIKE 'wait/synch/rwlock/%';
 UPDATE performance_schema.setup_consumers SET enabled = 'YES';
-UPDATE performance_schema.setup_timers SET timer_name = 'TICK';
+UPDATE performance_schema.setup_timers SET timer_name = 'TICK' WHERE name <> "wait";
 TRUNCATE TABLE performance_schema.events_waits_history_long;
 TRUNCATE TABLE performance_schema.events_waits_history;
 TRUNCATE TABLE performance_schema.events_waits_current;
@@ -576,6 +576,5 @@ flush privileges;
 UPDATE performance_schema.setup_instruments SET enabled = 'YES', timed = 'YES';
 UPDATE performance_schema.setup_consumers SET enabled = 'YES';
 UPDATE performance_schema.setup_timers SET timer_name = 'MICROSECOND' where name="idle";
-UPDATE performance_schema.setup_timers SET timer_name = 'CYCLE'       where name="wait";
 UPDATE performance_schema.setup_timers SET timer_name = 'NANOSECOND'  where name="stage";
 UPDATE performance_schema.setup_timers SET timer_name = 'NANOSECOND'  where name="statement";
--- a/mysql-test/suite/perfschema/t/dml_performance_timers.test
+++ b/mysql-test/suite/perfschema/t/dml_performance_timers.test
@@ -2,6 +2,7 @@
 
 --source include/not_embedded.inc
 --source include/have_perfschema.inc
+--source include/have_timer_cycle.inc
 
 --replace_column 2 <frequency> 3 <resolution> 4 <overhead>
 select * from performance_schema.performance_timers;
--- a/mysql-test/suite/perfschema/t/dml_setup_timers.test
+++ b/mysql-test/suite/perfschema/t/dml_setup_timers.test
@@ -2,6 +2,7 @@
 
 --source include/not_embedded.inc
 --source include/have_perfschema.inc
+--source include/have_timer_cycle.inc
 
 # Set to a known state
 update performance_schema.setup_timers
--- a/mysql-test/suite/perfschema/t/privilege.test
+++ b/mysql-test/suite/perfschema/t/privilege.test
@@ -291,7 +291,7 @@ TRUNCATE TABLE performance_schema.events
 --echo # Grant access to change tables with the root account
 
 GRANT UPDATE ON performance_schema.setup_consumers TO pfs_user_4;
-GRANT UPDATE ON performance_schema.setup_timers TO pfs_user_4;
+GRANT UPDATE, SELECT ON performance_schema.setup_timers TO pfs_user_4;
 GRANT UPDATE, SELECT ON performance_schema.setup_instruments TO pfs_user_4;
 GRANT DROP ON performance_schema.events_waits_current TO pfs_user_4;
 GRANT DROP ON performance_schema.events_waits_history TO pfs_user_4;
@@ -308,7 +308,11 @@ WHERE name LIKE 'wait/synch/mutex/%'
 
 UPDATE performance_schema.setup_consumers SET enabled = 'YES';
 
-UPDATE performance_schema.setup_timers SET timer_name = 'TICK';
+# We do not touch "wait", to avoid restoring it at the end of the test,
+# as its default value initialized at server startup is ambiguous:
+# it can be CYCLE or NANOSECOND depending on platform
+
+UPDATE performance_schema.setup_timers SET timer_name = 'TICK' WHERE name <> "wait";
 
 TRUNCATE TABLE performance_schema.events_waits_history_long;
 TRUNCATE TABLE performance_schema.events_waits_history;
@@ -324,8 +328,9 @@ flush privileges;
 UPDATE performance_schema.setup_instruments SET enabled = 'YES', timed = 'YES';
 UPDATE performance_schema.setup_consumers SET enabled = 'YES';
 
+# Restore the default values for the timers that we changed.
+# Note, we did not touch "wait", see above.
 UPDATE performance_schema.setup_timers SET timer_name = 'MICROSECOND' where name="idle";
-UPDATE performance_schema.setup_timers SET timer_name = 'CYCLE'       where name="wait";
 UPDATE performance_schema.setup_timers SET timer_name = 'NANOSECOND'  where name="stage";
 UPDATE performance_schema.setup_timers SET timer_name = 'NANOSECOND'  where name="statement";
 
--- a/mysys/my_rdtsc.c
+++ b/mysys/my_rdtsc.c
@@ -129,6 +129,31 @@ ulonglong my_timer_cycles_il_x86_64();
   clock_gettime(CLOCK_SGI_CYCLE) for Irix platforms,
   or on read_real_time for aix platforms. There is
   nothing for Alpha platforms, they would be tricky.
+
+  On the platforms that do not have a CYCLE timer,
+  "wait" events are initialized to use NANOSECOND instead of CYCLE
+  during performance_schema initialization (at the server startup).
+
+  Linux performance monitor (see "man perf_event_open") can
+  provide cycle counter on the platforms that do not have
+  other kinds of cycle counters. But we don't use it so far.
+
+  ARM notes
+  ---------
+  During tests on ARMv7 Debian, perf_even_open() based cycle counter provided
+  too low frequency with too high overhead:
+  MariaDB [performance_schema]> SELECT * FROM performance_timers;
+  +-------------+-----------------+------------------+----------------+
+  | TIMER_NAME  | TIMER_FREQUENCY | TIMER_RESOLUTION | TIMER_OVERHEAD |
+  +-------------+-----------------+------------------+----------------+
+  | CYCLE       | 689368159       | 1                | 970            |
+  | NANOSECOND  | 1000000000      | 1                | 308            |
+  | MICROSECOND | 1000000         | 1                | 417            |
+  | MILLISECOND | 1000            | 1000             | 407            |
+  | TICK        | 127             | 1                | 612            |
+  +-------------+-----------------+------------------+----------------+
+  Therefore, it was decided not to use perf_even_open() on ARM
+  (i.e. go without CYCLE and have "wait" events use NANOSECOND by default).
 */
 
 ulonglong my_timer_cycles(void)
